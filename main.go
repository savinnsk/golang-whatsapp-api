package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	// Import the SQLite driver package
	_ "github.com/mattn/go-sqlite3"
	//"github.com/mdp/qrterminal/v3"
	//"github.com/skip2/go-qrcode"
	"go.mau.fi/whatsmeow"
	wp "go.mau.fi/whatsmeow/binary/proto"
	"go.mau.fi/whatsmeow/store"
	"go.mau.fi/whatsmeow/store/sqlstore"
	"go.mau.fi/whatsmeow/types/events"
	waLog "go.mau.fi/whatsmeow/util/log"
	"google.golang.org/protobuf/proto"
	
)

var client *whatsmeow.Client



// eventHandler handles incoming events and dispatches them to the appropriate functions
func eventHandler(evt interface{}) {
    // Check if event is a message
    if evt, ok := evt.(*events.Message); ok {
        // Handle image messages

        // Handle text messages
        if evt.Message.GetConversation() != "" {
            go handleConversation(evt)
        }
    }
}

// handleConversation handles incoming text messages by generating an AI-generated text response and sending it back
func handleConversation(evt *events.Message) {
    msg:= `*Ol√°! Por favor, escolha uma das seguintes op√ß√µes:*

	1. Deseja Agendar Hor√°rio? üìÖ
	2. Ver Pre√ßos? üí≤
	3. Verificar seu Hor√°rio? ‚è∞
	4. Ligar para atendente? üìû
	5. Sair. üö™
 
	
Responda com o n√∫mero correspondente √† sua escolha.`
    // Verifique se a mensagem do usu√°rio √© um n√∫mero v√°lido (1 a 5)
    userInput := evt.Message.GetConversation()
    switch userInput {
    case "1", "2", "3", "4", "5":
        // O usu√°rio escolheu uma op√ß√£o v√°lida, voc√™ pode implementar a l√≥gica para cada op√ß√£o aqui
        handleUserChoice(evt, userInput)
    default:
        // O usu√°rio n√£o digitou um n√∫mero v√°lido, envie uma mensagem de erro
        sendErrorMessage(evt, msg)
    }
}
func handleUserChoice(evt *events.Message, choice string) {
    // Implemente a l√≥gica para cada op√ß√£o escolhida pelo usu√°rio
    switch choice {
    case "1":
        // O usu√°rio escolheu a op√ß√£o 1: Deseja Agendar Hor√°rio
        // Implemente a l√≥gica para esta op√ß√£o aqui
       sendResponse(evt, `*Voc√™ escolheu a op√ß√£o 1: Deseja Agendar Hor√°rio.*
        
        os seguintes hor√°rios est√£o dispon√≠veis:

        1 - 12:00am
        2 - 15:00pm
        
        `)


        sendResponse(evt, "*Por favor, responda com o n√∫mero correspondente ao hor√°rio desejado.*")
    case "2":
        // O usu√°rio escolheu a op√ß√£o 2: Ver Pre√ßos
        // Implemente a l√≥gica para esta op√ß√£o aqui
        sendResponse(evt, "Voc√™ escolheu a op√ß√£o 2: Ver Pre√ßos.")
    case "3":
        // O usu√°rio escolheu a op√ß√£o 3: Verificar seu Hor√°rio
        // Implemente a l√≥gica para esta op√ß√£o aqui
        sendResponse(evt, "Voc√™ escolheu a op√ß√£o 3: Verificar seu Hor√°rio.")
    case "4":
        // O usu√°rio escolheu a op√ß√£o 4: Ligar para atendente
        // Implemente a l√≥gica para esta op√ß√£o aqui
        sendResponse(evt, "Voc√™ escolheu a op√ß√£o 4: Ligar para atendente.")
    case "5":
        // O usu√°rio escolheu a op√ß√£o 5: Sair
        // Implemente a l√≥gica para esta op√ß√£o aqui
        sendResponse(evt, "Voc√™ escolheu a op√ß√£o 5: Sair.")
    }
}


func sendResponse(evt *events.Message, responseText string) string {
    client.SendMessage(context.Background(), evt.Info.Chat, &wp.Message{
        ExtendedTextMessage: &wp.ExtendedTextMessage{
            Text: proto.String(responseText),
            ContextInfo: &wp.ContextInfo{
                QuotedMessage: &wp.Message{
                    Conversation: proto.String(evt.Message.GetConversation()),
                },
                StanzaId:    proto.String(evt.Info.ID),
                Participant: proto.String(evt.Info.Sender.ToNonAD().String()),
            },
        },
    })

    return evt.Message.GetConversation()
}

// Fun√ß√£o para enviar uma mensagem de erro ao usu√°rio
func sendErrorMessage(evt *events.Message, errorMessage string) {
    sendResponse(evt, errorMessage)
}

func main() {
    configureLogging()

    container, err := initializeSQLStore()
    handleError(err)

  

	deviceStore, err := getFirstDeviceFromContainer(container)
	handleError(err)

    handleError(err)


	initializeWhatsMeowClient(deviceStore)

    // Check if the client is already logged in or perform the login process
    handleLogin()

    waitForInterruptSignal()
}

func configureLogging() {
    dbLog := waLog.Stdout("Database", "INFO", true)
    // Use dbLog if needed for database logging
    _ = dbLog
    // Configure other logging settings if needed
    // ...
}

func initializeSQLStore() (*sqlstore.Container, error) {
	dbLog := waLog.Stdout("Database", "INFO", true)
    return sqlstore.New("sqlite3", "file:examplestore.db?_foreign_keys=on", dbLog)
}

func getFirstDeviceFromContainer(container *sqlstore.Container) (*store.Device, error)  {
 return  container.GetFirstDevice()  
}

func initializeWhatsMeowClient(deviceStore *store.Device) {
    clientLog := waLog.Stdout("Client", "DEBUG", true)
    client = whatsmeow.NewClient(deviceStore, clientLog)
    client.AddEventHandler(eventHandler)
}



func handleLogin() {
	if client.Store.ID == nil {
		qrChan, _ := client.GetQRChannel(context.Background())
		err := client.Connect()
		handleError(err)

		// Create a file to save the QR code as a PNG image
		qrFile, err := os.Create("qrcode.png")
	
		if err != nil {
			panic(err)
		}
		handleError(err)
		defer qrFile.Close()

		// Print the QR code to the file
		for evt := range qrChan {
			if evt.Event == "code" {
				// Print the QR code to the file
				
				_, err := qrFile.Write([]byte(evt.Code))
				handleError(err)
			} else {
				fmt.Println("Login event:", evt.Event)
			}
		}
	} else {
		err := client.Connect()
		handleError(err)
	}
}


func waitForInterruptSignal() {
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    <-c

    client.Disconnect()
}

func handleError(err error) {
    if err != nil {
        panic(err)
    }
}
